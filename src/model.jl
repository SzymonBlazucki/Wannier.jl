using Printf: @printf

struct Model{T<:Real}
    # unit cell, 3 * 3, Å unit, each column is a lattice vector
    lattice::Mat3{T}

    # atomic positions, 3 * n_atoms, fractional coordinates,
    # each column is a position
    atom_positions::Matrix{T}

    # atomic labels, n_atoms
    atom_labels::Vector{String}

    # number of kpoints along 3 directions
    kgrid::Vec3{Int}

    # kpoints array, fractional coordinates, 3 * n_kpts
    # n_kpts is the last index since julia array is column-major
    kpoints::Matrix{T}

    # b vectors satisfying b1 condition
    bvectors::BVectors{T}

    # is band frozen? n_bands * n_kpts
    frozen_bands::BitMatrix

    # Mmn matrix, n_bands * n_bands * n_bvecs * n_kpts
    M::Array{Complex{T},4}

    # Amn matrix, n_bands * n_wann * n_kpts
    A::Array{Complex{T},3}

    # eigenvalues, n_bands * n_kpts
    E::Matrix{T}

    # spn matrix, n_bands * n_bands * 3 * n_kpts
    S::Array{Complex{T},4}

    # I put these frequently used variables in the last,
    # since they are generated by the constructor.

    # reciprocal cell, 3 * 3, Å⁻¹ unit, each column is a lattice vector
    recip_lattice::Mat3{T}

    # number of atoms
    n_atoms::Int

    # number of bands
    n_bands::Int

    # number of Wannier functions (WFs)
    n_wann::Int

    # number of kpoints
    n_kpts::Int

    # number of b vectors
    n_bvecs::Int
end

function Model(
    lattice::Mat3{T},
    atom_positions::Matrix{T},
    atom_labels::Vector{String},
    kgrid::Vec3{Int},
    kpoints::Matrix{T},
    bvectors::BVectors{T},
    frozen_bands::AbstractMatrix{Bool},
    M::Array{Complex{T},4},
    A::Array{Complex{T},3},
    E::Matrix{T},
    S::Array{Complex{T},4},
) where {T<:Real}
    return Model(
        lattice,
        atom_positions,
        atom_labels,
        kgrid,
        kpoints,
        bvectors,
        BitMatrix(frozen_bands),
        M,
        A,
        E,
        S,
        get_recip_lattice(lattice),
        length(atom_labels),
        size(A, 1),
        size(A, 2),
        size(A, 3),
        bvectors.n_bvecs,
    )
end

function Model(
    lattice::Mat3{T},
    atom_positions::Matrix{T},
    atom_labels::Vector{String},
    kgrid::Vec3{Int},
    kpoints::Matrix{T},
    bvectors::BVectors{T},
    frozen_bands::AbstractMatrix{Bool},
    M::Array{Complex{T},4},
    A::Array{Complex{T},3},
    E::Matrix{T},
) where {T<:Real}
    n_bands, n_kpts = size(E)
    return Model(
        lattice,
        atom_positions,
        atom_labels,
        kgrid,
        kpoints,
        bvectors,
        frozen_bands,
        M,
        A,
        E,
        Array{Complex{T},4}(undef, n_bands, n_bands, 3, n_kpts),
    )
end

function pprint(model::Model)
    @printf("lattice: Å\n")
    for i in 1:3
        @printf("  a%d: %8.5f %8.5f %8.5f\n", i, model.lattice[:, i]...)
    end
    println()

    @printf("atoms: fractional\n")
    for i in 1:(model.n_atoms)
        l = model.atom_labels[i]
        pos = model.atom_positions[:, i]
        @printf(" %3s: %8.5f %8.5f %8.5f\n", l, pos...)
    end
    println()

    @printf("n_bands: %d\n", model.n_bands)
    @printf("n_wann : %d\n", model.n_wann)
    @printf("kgrid  : %d %d %d\n", model.kgrid...)
    @printf("n_kpts : %d\n", model.n_kpts)
    @printf("n_bvecs: %d\n", model.n_bvecs)

    println()
    pprint(model.bvectors)
    return nothing
end

"""Rotate the gauge of a Model"""
function rotate_gauge(model::Model, A::Array{T,3}) where {T<:Number}
    n_bands = model.n_bands
    n_kpts = model.n_kpts
    size(A)[[1, 3]] != (n_bands, n_kpts) && error("A must have size (n_bands, ?, n_kpts)")
    # The new n_wann
    n_wann = size(A, 2)

    # EIG
    E = model.E
    E2 = zeros(eltype(E), n_wann, n_kpts)
    H = zeros(eltype(model.A), n_wann, n_wann)
    # tolerance for checking Hamiltonian
    atol = 1e-8
    for ik in 1:n_kpts
        Aₖ = A[:, :, ik]
        H .= Aₖ' * diagm(0 => E[:, ik]) * Aₖ
        if norm(H - diagm(0 => diag(H))) > atol
            error("H is not diagonal after gauge rotation")
        end
        if any(imag(diag(H)) .> atol)
            error("H has non-zero imaginary part")
        end
        E2[:, ik] = real(diag(H))
    end

    # MMN
    M = model.M
    kpb_k = model.bvectors.kpb_k
    M2 = rotate_mmn(M, kpb_k, A)

    # AMN
    A2 = eyes_amn(eltype(M), n_wann, n_kpts)

    model2 = Model(
        model.lattice,
        model.atom_positions,
        model.atom_labels,
        model.kgrid,
        model.kpoints,
        model.bvectors,
        zeros(Bool, n_wann, n_kpts),
        M2,
        A2,
        E2,
    )
    return model2
end

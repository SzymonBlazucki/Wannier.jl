"""
    struct KRVectors

Contains both kpoints mapping and R vectors.

# Fields
- `lattice`: each column is a lattice vector
- `kgrid`: number of kpoints along 3 directions
- `kpoints`: each column is a kpoint in fractional coordinates
- `k_xyz`: kpoints mappings from `ik` to `[ikx, iky, ikz]`
- `xyz_k`: kpoints mappings from `[ikx, iky, ikz]` to `ik`
- `Rvectors`: R vectors, can be either `RVectors` or `RVectorsMDRS`
- `recip_lattice`: each column is a reciprocal lattice vector
- `n_kpts`: number of kpoints
- `n_rvecs`: number of R vectors
- `n_r̃vecs`: number of R̃ vectors, only for MDRS
"""
struct KRVectors{T<:Real,RV<:Union{RVectors{T},RVectorsMDRS{T}}}
    # unit cell, 3 * 3, Å unit, each column is a lattice vector
    lattice::Mat3{T}

    # number of kpoints along 3 directions
    kgrid::Vec3{Int}

    # kpoints array, fractional coordinates, 3 * n_kpts
    # n_kpts is the last index since julia array is column-major
    kpoints::Matrix{T}

    # kpoints mappings between ik to [ikx, iky, ikz], n_kpts
    k_xyz::Vector{Vec3{Int}}
    # n_kx, n_ky, n_kz
    xyz_k::Array{Int,3}

    # R vectors for Fourier transform
    Rvectors::RV

    # I put these frequently used variables in the last,
    # since they are generated by the constructor.

    # reciprocal cell, 3 * 3, Å⁻¹ unit, each column is a lattice vector
    recip_lattice::Mat3{T}

    # number of kpoints
    n_kpts::Int
end

function Base.getproperty(x::KRVectors{T,RV}, sym::Symbol) where {T<:Real,RV<:RVectors{T}}
    if sym == :n_rvecs
        return getproperty(x.Rvectors, sym)
    else
        # fallback to getfield
        getfield(x, sym)
    end
end

function Base.getproperty(
    x::KRVectors{T,RV}, sym::Symbol
) where {T<:Real,RV<:RVectorsMDRS{T}}
    if sym == :n_rvecs
        return getproperty(x.Rvectors, sym)
    elseif sym == :n_r̃vecs
        return getproperty(x.Rvectors, sym)
    else
        # fallback to getfield
        getfield(x, sym)
    end
end

"""
    KRVectors(lattice, kgrid, kpoints, k_xyz, xyz_k, Rvectors)

A friendly constructor for `KRVectors`.

Remaining fields are generated automatically based on input arguments.

# Arguments
- `lattice`: each column is a lattice vector
- `kgrid`: number of kpoints along 3 directions
- `kpoints`: each column is a kpoint in fractional coordinates
- `k_xyz`: kpoints mappings from `ik` to `[ikx, iky, ikz]`
- `xyz_k`: kpoints mappings from `[ikx, iky, ikz]` to `ik`
- `Rvectors`: R vectors, can be either `RVectors` or `RVectorsMDRS`
"""
function KRVectors(
    lattice::Mat3{T},
    kgrid::Vec3{Int},
    kpoints::Matrix{T},
    k_xyz::Vector{Vec3{Int}},
    xyz_k::Array{Int,3},
    Rvectors::Union{RVectors{T},RVectorsMDRS{T}},
) where {T<:Real}
    recip_lattice = get_recip_lattice(lattice)
    n_kpts = size(kpoints, 2)
    return KRVectors(lattice, kgrid, kpoints, k_xyz, xyz_k, Rvectors, recip_lattice, n_kpts)
end

"""
    KRVectors(lattice, kgrid, kpoints, Rvectors)

A friendly constructor for `KRVectors`.

The kpoint mappings `k_xyz` and `xyz_k` are generated based on `kpoints` and `kgrid`.
Remaining fields are generated automatically based on input arguments.

# Arguments
- `lattice`: each column is a lattice vector
- `kgrid`: number of kpoints along 3 directions
- `kpoints`: each column is a kpoint in fractional coordinates
- `Rvectors`: R vectors, can be either `RVectors` or `RVectorsMDRS`
"""
function KRVectors(
    lattice::Mat3{T},
    kgrid::Vec3{Int},
    kpoints::Matrix{T},
    Rvectors::Union{RVectors{T},RVectorsMDRS{T}},
) where {T<:Real}
    k_xyz, xyz_k = get_kpoint_mappings(kpoints, kgrid)
    return KRVectors(lattice, kgrid, kpoints, k_xyz, xyz_k, Rvectors)
end

"""
    KRVectors(Rvectors)

Construct a `KRVectors` from `RVectors` or `RVectorsMDRS`.

The kpoints part are just empty.

!!! note

    If we only need to Wannier interpolate operators, e.g., interpolate band structure
    from `tb.dat` file, then we don't need info on the kpoint grid of Wannierization,
    so we can just leave it empty.
"""
function KRVectors(Rvectors::Union{RVectors{T},RVectorsMDRS{T}}) where {T<:Real}
    kgrid = Vec3{Int}([0, 0, 0])  # no info on kgrid
    k_xyz = Vector{Vec3{Int}}(undef, 0)
    xyz_k = Array{Int,3}(undef, 0, 0, 0)
    kpoints = zeros(T, 3, 0)
    return KRVectors(Rvectors.lattice, kgrid, kpoints, k_xyz, xyz_k, Rvectors)
end

function Base.show(io::IO, x::KRVectors)
    @printf(io, "recip_lattice: Å⁻¹\n")
    for i in 1:3
        @printf(io, "  a%d: %8.5f %8.5f %8.5f\n", i, x.recip_lattice[:, i]...)
    end
    @printf(io, "kgrid  : %d %d %d\n", x.kgrid...)
    @printf(io, "n_kpts : %d\n", x.n_kpts)
    println(io)

    return show(io, x.Rvectors)
end
